import { Plugin, Transaction, EditorState } from 'prosemirror-state';
import { collab, receiveTransaction, sendableSteps, getVersion } from 'prosemirror-collab';
import { Step } from 'prosemirror-transform';
import { Node } from 'prosemirror-model';
import * as pako from 'pako';

import Extension from '../../../utils/Extension';
import { EditorEvents } from '../../../utils/EventBus';
import { debounce, throttle } from '../../../helpers';
import { default as randomColor } from './randomColor';
import { CollabWebSocketConnectionManager } from './CollabWebSocketConnectionManager';
import { getCursorPlugin } from './cursorPlugin';

export interface CollabUser {
  connectionId: string;
  identity: string;
  displayName: string;
  cursorPosition: number;
  cursorColor: string;
};

export interface CollabOptions {
  documentUrn?: string;
  auth?: string;
  userIdentity?: string;
  connectionManager?: CollabWebSocketConnectionManager|undefined;
  /**
   * Joined collaboration and syncing changes
   */
  onOnline?: () => void;
  /**
   * Disconnected
   */
  onOffline?: () => void;
  /**
   * Might be in case of too large document
   * Don't exchange changeset anymore, but still show users and etc ...
   */
  onCollabDisabled?: () => void;
  /**
   * When someone persisted document remotely (to DeskPRO db and etc...)
   * In case of disabled collab we need to notify local user that someone changed document and he need to reload
   */
  onRemoteSave?: (collabStatus: CollabStatus) => void;
  /**
   * When document persisted locally (to DeskPRO db and etc...)
   */
  onLocalSave?: (callback: () => void) => void;
  /**
   * On collab users
   */
  onUsers?: (users: CollabUser[]) => void;
};


/**
 * Collaboration status
 */
enum CollabStatus {
  DISCONNECTED = "disconnected",
  CONNECTING = "connecting",
  JOIN_REQUEST_SEND = "join_request_send",
  DOCUMENT_INITIALIZATION = "document_initialization",
  STREAMING = "streaming",
  /**
   * Collab might be disabled for example in case of too large document
   * but we still might show users and etc ...
   */
  DISABLED = "disabled"
}

/**
 * Collab server response types
 */
enum CollabServerMessageAction {
  CHANGES = "changes",
  USERS = "users",
  DOCUMENT = "document",
  EVENT = "event"
}

/**
 * Collab edit changes that exhanged between all clients
 */
interface CollabEditChanges {
  version: number;
  event: {
    clientID: number; // ProseMirror clientId, generated by PM automatically
    steps: any[];     // array of JSON ProseMirror/Step
  };
}

/**
 * Structure for `compressed payload chunk`
 */
interface CompressionChunk {
  payloadId: string;
  idx: number;
  data: string;
}

/**
 * Structure for `changes` message from server
 */
interface CollabServerMessageChanges extends CollabEditChanges {
  action: CollabServerMessageAction.CHANGES;
  documentUrn: string;
}

/**
 * Structure for `users` message from server
 */
interface CollabServerMessageConnectedUsers {
  action: CollabServerMessageAction.USERS;
  documentUrn: string;
  users: CollabUser[];
}

/**
 * Structure for `document` message from server
 */
interface CollabServerMessageDocument {
  action: CollabServerMessageAction.DOCUMENT;
  content: string;
  version: number;
  documentUrn: string;
  changes: CollabEditChanges[];
  isCollabDisabled: boolean;
}

/**
 * Structure for `event` message from server
 */
enum CollabServerMessageEventType {
  // Someone persisted document locally (to DeskPRO db or etc...)
  PERSISTED = "persisted"
}
interface CollabServerMessageEvent {
  action: CollabServerMessageAction.EVENT;
  documentUrn: string;
  type: CollabServerMessageEventType;
  data?: any;
}

/**
 * Collaboration extension
 */
class Collaboration extends Extension<CollabOptions> {
  name = 'collabwebsocket';

  protected collabStatus: CollabStatus = CollabStatus.DISCONNECTED;
  protected collabStatusChangedAt: number = Date.now();

  protected cursorPlugin: Plugin = getCursorPlugin();
  protected collabPlugin: Plugin = collab({ version: 1 });

  protected cursorPosition = 1;
  protected socket: WebSocket|undefined = undefined;

  protected changesBuffer: CollabEditChanges[] = [];
  protected users: CollabUser[] = [];

  protected compressionChunksBuffer: Record<string, CompressionChunk[]> = {};

  // remote cursors instant update routine
  protected rcCursorPosition: number = 1;
  protected rcTimeoutId: any = undefined;
  protected rcUsersBuffer: CollabUser[] = [];
  protected rcLockUsersUpdateDelay: number = 3000;
  protected rcLockUsersUpdate: boolean = false;
  protected rcNodeSize: number = 0;

  initialize() {
    this.log('[Collaboration] Initializing...');

    if (!this.view || !this.editor) {
      this.log("No view or editor");
      return;
    }

    const state = this.view.state;
    if (sendableSteps(state)) {
      this.log(
        "State already has sendable steps. It is not normal situation. Server might get not initial content from this client"
      );
    }

    const connectionManager = this.options.connectionManager;
    if (!connectionManager) {
      this.log("No connection manager");
      return;
    }

    const onConnectionOnline = (websocket: WebSocket) => {
      try {
        this.onWebsocketOnline(websocket);
      } catch(e) {
        console.error(e);
      }
    };
    const onConnectionOffline = () => {
      try {
        this.onWebsocketOffline();
      } catch(e) {
        console.error(e);
      }
    }

    connectionManager.onOnline(onConnectionOnline);
    connectionManager.onOffline(onConnectionOffline);

    if (this.options.onLocalSave) {
      this.options.onLocalSave(this.onLocalSave.bind(this));
    }

    this.editor.on(EditorEvents.TRANSACTION, debounce((tr: Transaction) => {
      this.onChange(tr);
    }, 250));
    // Subscribe to TRANSACTION again without debounce to be able to update remote coursors positions on local edit
    this.editor.on(EditorEvents.TRANSACTION, this.remoteCursorsUpdater.bind(this));
    this.editor.on(EditorEvents.BEFORE_DESTROY, () => {
      this.leaveCollab();
      connectionManager.unsibscribeOnline(onConnectionOnline);
      connectionManager.unsibscribeOffline(onConnectionOffline);
      this.clearState();
    });
  }

  clearState() {
    this.setCollabStatus(CollabStatus.DISCONNECTED);
    this.socket = undefined;
    this.compressionChunksBuffer = {};
    this.changesBuffer = [];
    this.users = [];
    this.cursorPosition = 1;
    this.rcUsersBuffer = [];
    this.rcCursorPosition = 1;
    this.rcNodeSize = 0;
    this.applyUsersInfo();
  }

  /**
   * Local Editor changes callback
   *
   * @param tr
   */
  private onChange(tr: Transaction) {
    if (!this.isStreaming()) {
      this.log("Have changes but still not streaming");
      return;
    }

    // Websocket not always close fast. It may be in a `CLOSING` status for a long time (up to the 60s)
    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
      return;
    }

    this.sendChangesOnServer();
  }

  /**
   * Instantly update remote cursors on change
   * Update remote cursors position according to our local changes
   * Remote cursors positions updated only locally (we don't broadcast them),
   * other users will recieve changes, update their cursors positions and then broadcast new positions
   *
   * But locally we updated remote cursors positions manually to avoid cursors jumping (because of network delay)
   *
   * @param tr
   */
  private remoteCursorsUpdater(tr: Transaction) {
    if (!this.isStreaming() || !this.view) {
      return;
    }

    const view = this.view;
    const newState = view.state;
    const prevCursorPosition = this.rcCursorPosition;
    const prevNodeSize = this.rcNodeSize;
    this.rcCursorPosition = newState.selection.$head.pos;
    this.rcNodeSize = newState.doc.nodeSize;

    if (!tr.docChanged)
      return;

    if (this.rcNodeSize === prevNodeSize)
      return;

    // If no local sendable - means got changes from remote users
    // skip remote cursors instant update
    if (!sendableSteps(newState))
      return;

    let aheadUsersExist = false;
    const delta = this.rcNodeSize - prevNodeSize;

    const users = this.users.map(u => {
      if (u.cursorPosition >= prevCursorPosition) {
        aheadUsersExist = true;
        u.cursorPosition += delta;

        if (u.cursorPosition < this.rcCursorPosition) {
          u.cursorPosition = this.rcCursorPosition;
        }
      }

      return u;
    });

    if (aheadUsersExist && delta) {
      // need to lock cursors updates from collab server for some seconds to prevent cursor jumping
      // we updated remote curosrs manually for local user
      // but collab server will send remote coursors positions too (with some delay)
      // take a pause and ignore those updates for several seconds until local and remote info syncronized
      this.rcLockUsersUpdate = true;
      this.users = users;
      this.applyUsersInfo(false);

      if (this.rcTimeoutId) clearTimeout(this.rcTimeoutId);

      this.rcTimeoutId = setTimeout(()=>{
        this.rcLockUsersUpdate = false;
        this.log("Unlock remote users update");
        if (this.rcUsersBuffer.length) {
          this.log("Load users from buffer");
          this.users = this.rcUsersBuffer;
          this.rcUsersBuffer = [];
          this.applyUsersInfo();
        }
      }, this.rcLockUsersUpdateDelay);
    }
  }

  /**
   * WebSocketConnectionManager onOnline callback
   * Start joining collaboration
   */
  private onWebsocketOnline(websocket: WebSocket) {
    if (this.collabStatus !== CollabStatus.DISCONNECTED) {
      return;
    }

    if (!this.view) {
      this.log("this.view is undefined");
      return;
    }

    this.log("Pickup websocket");
    this.setCollabStatus(CollabStatus.CONNECTING);
    this.socket = websocket;

    this.setupWebsocketEvents(websocket);
    this.joinCollab();
  }

  /**
   * WebSocketConnectionManager onOffline callback
   */
  private onWebsocketOffline() {
    this.clearState();
  }

  private onLocalSave() {
    if (!this.isStreaming()) {
      return;
    }

    const payload = JSON.stringify({
      action: "sendEvent",
      documentUrn: this.options.documentUrn,
      type: CollabServerMessageEventType.PERSISTED
    });

    if (this.socket) {
      this.socket.send(payload);
    }
  }

  private joinCollab() {
    if (this.collabStatus !== CollabStatus.CONNECTING) {
      return;
    }

    this.log("Joining collab");

    if (!this.view) {
      this.log("this.view is undefined");
      return;
    }

    this.compressionChunksBuffer = {};

    const state = this.view.state;
    const payload = JSON.stringify({
      action: "joinCollab",
      document: {
        urn: this.options.documentUrn,
        version: getVersion(state),
        content: state.doc.toJSON()
      },
      cursorPosition: this.cursorPosition,
      authToken: this.options.auth,
      sub: this.options.userIdentity,
      name: "Petya" // @TODO this is only for local testing
    });

    this.sendCompressedPayload("joinCollab", payload);

    this.setCollabStatus(CollabStatus.JOIN_REQUEST_SEND);
  }

  private leaveCollab() {
    this.log("Leaving collab");

    if (this.socket) {
      this.socket.send(JSON.stringify({
        action: "leaveCollab",
        documentUrn: this.options.documentUrn
      }));
    }
  }

  private setupWebsocketEvents(websocket: WebSocket): void {

    // WEBSOCKET ON MESSAGE
    websocket.addEventListener('message', (event: MessageEvent) => {
      if (this.isLeftCollab()) {
        return;
      }

      let data = JSON.parse(event.data);

      // We use one connection for multiple documents
      if (data.documentUrn !== this.options.documentUrn) {
        return;
      }

      data = this.getCompressedPayload(data);
      if (typeof data === 'boolean') {
        return;
      }

      data = data as (
        CollabServerMessageChanges
        |CollabServerMessageConnectedUsers
        |CollabServerMessageDocument
        |CollabServerMessageEvent
      )

      this.log('Got websocket message', data);

      if (!this.view) {
        this.log("this.view is undefined");
        return;
      }
      const view = this.view;

      switch (data.action) {

        //
        // new collab changes from server
        //
        case CollabServerMessageAction.CHANGES:

          if (this.isStreamChanges()) {
            try {
              this.applyChangesFromServer([data as CollabEditChanges]);
            } catch(err) {
              console.error(err);
              this.clearState();
              return;
            }
          } else if (this.collabStatus !== CollabStatus.DISABLED) {
            this.changesBuffer[data.version] = data as CollabEditChanges;
          } else {
            this.log("Collab disabled, skip remote changes");
          }

          break;

        //
        // updated collab users info (names, cursor positions, etc ...)
        //
        case CollabServerMessageAction.USERS:

          const users = data.users
            .filter((u: CollabUser) => {
              return u.identity !== this.options.userIdentity
                     && u.identity !== undefined && u.identity.length > 0;
            })
            .map((u: CollabUser) => {
              u.cursorColor = this.selectColor(u)
              return u;
            });

          if (this.rcLockUsersUpdate) {
            this.rcUsersBuffer = users;
            break;
          }

          this.users = users;
          // display cursors in editor if we are fully connected and synced
          if (this.isStreamUsers()) {
            this.applyUsersInfo();
          }

          break;

        //
        // Get broadcasted event
        //
        case CollabServerMessageAction.EVENT:

          switch (data.type) {
            case CollabServerMessageEventType.PERSISTED:
              this.log("Get `persisted` broadcasted event");
              if (this.options.onRemoteSave) this.options.onRemoteSave(this.collabStatus);

              break;

            default:
                this.log("Unknown event type received: ", data.type);
          }

          break;

        //
        // whole document at last saved version and latest changes
        // sent for every newly connected clients
        // or when document status changed
        //
        case CollabServerMessageAction.DOCUMENT:

          const isCollabDisabled = data.isCollabDisabled !== undefined && data.isCollabDisabled === true;

          // Document initialization in case of JOIN_REQUEST_SEND status
          if (this.collabStatus === CollabStatus.JOIN_REQUEST_SEND) {
            this.setCollabStatus(CollabStatus.DOCUMENT_INITIALIZATION);

            if (getVersion(view.state) < data.version ) {
              this.loadDocument(data.content, data.version);
            }

            if (data.changes && data.changes.length) {
              this.log("Apply initial changes from server");
              try {
                this.applyChangesFromServer(data.changes);
              } catch(err) {
                console.error(err);
                this.clearState();
                return;
              }
            }

            // during document initialization we already connected to collab and getting new changes
            // apply them from buffer
            while (this.changesBuffer.length) {
              this.log("Apply change buffer", this.changesBuffer);
              const bufferCopy = this.changesBuffer;
              this.changesBuffer = [];
              try {
                this.applyChangesFromServer(bufferCopy);
              } catch(err) {
                console.error(err);
                this.clearState();
                return;
              }
            }

            if (this.users) {
              this.log("Setup initial cursor positions");
              this.applyUsersInfo();
            }

            this.setCollabStatus(CollabStatus.STREAMING);

            // now send possible local changes on server
            if (!isCollabDisabled) {
              this.sendChangesOnServer();
            }
          }

          if (isCollabDisabled) {
            this.setCollabStatus(CollabStatus.DISABLED);
          }

          break;

        default:
          this.log("Unknown action from collab server");
      }
    });

    // WEBSOCKET ON ERROR
    websocket.addEventListener('error', event => {
      if (this.isLeftCollab()) {
        return;
      }

      this.log('Webscoket Error', event);
      return;
    });
  }

  /**
   * Send local changes and cursor position on server
   */
  private sendChangesOnServer() {
    if (!this.view) {
      this.log("this.view is undefined");
      return;
    }

    const view = this.view;
    const newState = view.state;
    let sendable = sendableSteps(newState)

    if (sendable && !this.isStreamChanges()) {
      this.log("There is some sendable but collab disabled. Skip changes broadcasting");
      sendable = undefined;
    }

    if (sendable) {
      this.log("There is some sendable");
      const payload = JSON.stringify({
        action: "addChanges",
        version: sendable.version,
        steps: sendable.steps ? sendable.steps.map(s => s.toJSON()) : [],
        clientID: sendable.clientID,
        documentUrn: this.options.documentUrn
        // for now send cursor position as standalone call
        // cursorPosition: newState.selection.$head.pos
      });

      this.sendCompressedPayload("addChanges", payload);
    }

    if (this.isStreamUsers() && this.cursorPosition !== newState.selection.$head.pos) {
      this.cursorPosition = newState.selection.$head.pos;
      this.log("Broadcast cursor position", this.cursorPosition);
      const payload = JSON.stringify({
        action: "setCursorPosition",
        documentUrn: this.options.documentUrn,
        cursorPosition: this.cursorPosition
      });

      if (this.socket) {
        this.socket.send(payload);
      }
    }
  }

  /**
   * Send current document on server and create `checkpoint`
   * This checkpoint will be used by newly joined clients
   */
  sendDocumentOnServer = throttle((doc: Node, version: number) => {
    this.log("Save document on server, version: ", version);

    if (!this.socket) {
      return;
    }

    if (!this.isStreamChanges()) {
      this.log("Collab disabled. Skip document broadcasting");
      return;
    }

    const payload = JSON.stringify({
      action: "setDocument",
      document: {
        urn: this.options.documentUrn,
        version: version,
        content: doc.toJSON()
      }
    });

    this.sendCompressedPayload("setDocument", payload);
  }, 1000);

  private applyChangesFromServer(changes: CollabEditChanges[]) {
    if (!this.view) {
      this.log("this.view is undefined");
      return;
    }

    if (!this.isStreamChanges()) {
      console.log("Collab disabled. Skip applying changes from server.");
    }

    const view = this.view;

    changes.forEach(editChanges => {
      const currentVersion = getVersion(view.state);
      if (currentVersion >= editChanges.version) {
        this.log(this.options.documentUrn,
          `Got request to apply changes with lesser version ${editChanges.version} than current version ${currentVersion}. Skip it.`,
          editChanges
        );

        return;
      }

      // PM applying steps magic
      const steps: Step[] = editChanges.event.steps.map(
        (j: { [key: string]: any }) =>
          Step.fromJSON(view.state.schema, j)
      );
      const clientIds = new Array(steps.length).fill(editChanges.event.clientID);

      view.dispatch(
        receiveTransaction(view.state, steps, clientIds)
      );
    });

    // Periodically we send our document on server to create `checkpoints`
    // Send document only if it completely synced with all clients ( means there are no sendable)
    const state = view.state;
    if (!sendableSteps(state)) {
      this.log("Document fully synced. Schedule sendDocumentOnServer with version", getVersion(state));
      this.sendDocumentOnServer(state.doc, getVersion(state));
    }
  }

  /**
   * Show cursors
   */
  private applyUsersInfo(callCallback = true) {
    if (!this.view) {
      this.log("this.view is undefined");
      return;
    }

    const view = this.view;

    const curTr = view.state.tr;
    curTr.setMeta(this.cursorPlugin, {
      type: 'receive',
      users: this.users
    });
    view.dispatch(curTr);

    if (this.options.onUsers && callCallback) {
      this.options.onUsers(this.users);
    }
  }

  /**
   * Completly substitute local document content with version from collab server
   */
  private loadDocument(content: any, version: number) {
    this.log("Load doc from server");

    if (!this.view) {
      this.log("this.view is undefined");
      return;
    }
    const view = this.view;
    const doc = Node.fromJSON(view.state.schema, content);
    this.rcNodeSize = doc.nodeSize;

    // filter out collab plugin because we need to re-create it with new version
    const plugins = view.state.plugins.filter(p => p !== this.collabPlugin);
    this.collabPlugin = collab({version: version});
    plugins.push(this.collabPlugin);

    const newState = EditorState.create({
      schema: view.state.schema,
      doc: doc,
      plugins: plugins,
      storedMarks: view.state.storedMarks
    });
    view.updateState(newState);
  }

  private sendCompressedPayload(action: string, payload: string) {
    if (!this.socket)  return;

    // if size under the API limit send as it is
    if (payload.length < 31744) {
      this.socket.send(payload);

      return;
    }

    // compress and send by chunks
    const chunks: string[] = [];
    const deflate = new pako.Deflate({
      chunkSize: 15360, // + ~50% for base64 in result should be < 32kb
      to: "string"
    });
    deflate.onData = (chunk: any) => chunks.push(Buffer.from(chunk).toString("base64"));
    deflate.push(payload, true);
    const payloadId = this.options.documentUrn
      + "."
      + String(Date.now())
      + Math.random().toString(36).substring(7);

    chunks.forEach((chunk, idx) => {
      if (this.socket) {
        this.socket.send(JSON.stringify({
          action: action,
          compression: {
            payloadId: payloadId,
            numChunks: chunks.length,
            chunkIdx: idx,
            chunkData: chunk
          }
        }));
      }
    });
  }

  private getCompressedPayload(payload: Record<string, any>): Record<string, any>|boolean {

    if (payload.compression === undefined) {
      return payload;
    }

    this.log("[Compression] detected");

    const meta = payload.compression;

    if (!this.validateCompressionMeta(meta)) {
      this.log("[Compression] compression meta is invalid");

      return false;
    }

    const numChunks = meta.numChunks;
    const currChunk: CompressionChunk = {
      payloadId: meta.payloadId,
      idx: meta.chunkIdx,
      data: meta.chunkData,
    };

    if (!this.compressionChunksBuffer[currChunk.payloadId]) {
      this.compressionChunksBuffer[currChunk.payloadId] = [];
    }
    this.compressionChunksBuffer[currChunk.payloadId].push(currChunk);

    // If all chunks received - decompress
    if (this.compressionChunksBuffer[currChunk.payloadId].length === numChunks) {
      this.log("[Compression] all chunks received. Decompress ...")
      const inflate = new pako.Inflate({
        to: "string"
      });
      this.compressionChunksBuffer[currChunk.payloadId].sort((c1: CompressionChunk, c2: CompressionChunk) => c1.idx - c2.idx);
      this.compressionChunksBuffer[currChunk.payloadId].forEach((c, idx) => {
        inflate.push(Buffer.from(c.data, "base64").toString(), idx === numChunks - 1);
      });

      delete this.compressionChunksBuffer[currChunk.payloadId];

      if (inflate.err) {
        this.log("[Compression]", inflate.msg);
        return false;
      }

      return JSON.parse(inflate.result as string);
    }

    this.log("[Compression] Waiting for all chunks ...")

    return true;
  }

  private validateCompressionMeta(meta: Record<string, any>) {
    if (!meta
      || meta.payloadId === undefined
      || meta.numChunks === undefined
      || meta.chunkIdx === undefined
      || meta.chunkData === undefined) {
      return false;
    }

    return true;
  }

  private setCollabStatus(collabStatus: CollabStatus) {
    if (this.collabStatus !== collabStatus) {
      this.log(`Collab status changed to ${collabStatus}`);
    }
    const prevStatus = this.collabStatus;
    this.collabStatus = collabStatus;
    const isStatusChanged = prevStatus !== this.collabStatus;

    if (isStatusChanged) this.collabStatusChangedAt = Date.now();

    if ((prevStatus === CollabStatus.STREAMING || prevStatus === CollabStatus.DISABLED)
        && isStatusChanged
        && this.collabStatus !== CollabStatus.DISABLED
        && this.options.onOffline) {
      this.options.onOffline();
    }

    if (this.collabStatus === CollabStatus.STREAMING
        && isStatusChanged
        && this.options.onOnline) {
      this.options.onOnline();
    }

    if (this.collabStatus === CollabStatus.DISABLED
        && isStatusChanged
        && this.options.onCollabDisabled) {
      this.options.onCollabDisabled();
    }
  }

  /**
   * Means we initialized document and send/receive changes||users||etc.. in real time
   */
  private isStreaming() {
    return this.isStreamChanges() || this.isStreamUsers();
  }

  /**
   * Means we initialized document and send/receive changes in real time
   */
  private isStreamChanges() {
    return this.collabStatus === CollabStatus.STREAMING;
  }

  /**
   * Means we initialized document and send/receive users info
   */
  private isStreamUsers() {
    return this.collabStatus === CollabStatus.STREAMING || this.collabStatus === CollabStatus.DISABLED;
  }

  /**
   * Means we left collaboration and don't active anymore
   */
  private isLeftCollab() {
    return this.collabStatus === CollabStatus.DISCONNECTED;
  }

  private selectColor(user: CollabUser): string {
    const existingUser = this.users.filter((u: CollabUser) => u.identity === user.identity);
    if (existingUser.length) {
      return existingUser[0].cursorColor;
    }
    const color = randomColor();

    return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
  }

  private log(...args: any) {
    const id = (this.options.documentUrn as string).split(':').pop();
    console.log(id, ...args);
  }

  /**
   * Default options for the extension.
   */
  protected get defaultOptions() {
    return {
      documentUrn: "",
      auth: "",
      userIdentity: "",
      connectionManager: undefined
    };
  }

  get plugins(): Plugin[] {
    return [
      this.cursorPlugin,
      this.collabPlugin,
      // Plugin that just disable editor if offline
      new Plugin({
        props: {
          editable: (state: EditorState) => {
            if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
              return false;
            }

            return this.isStreaming();
          }
        }
      })
    ];
  }
}

export default Collaboration;
